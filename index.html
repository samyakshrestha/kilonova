<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Real-Time Kilonova Visualization</title>
    <style>
      :root {
        --panel-bg: rgba(6, 11, 24, 0.84);
        --panel-bg-2: rgba(10, 19, 38, 0.74);
        --panel-border: rgba(116, 168, 255, 0.34);
        --text: #eaf2ff;
        --muted: #a8bfdc;
        --accent: #9fd6ff;
        --accent-2: #72b5ff;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: "Avenir Next", "Segoe UI", "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
        color: var(--text);
      }

      #app {
        position: fixed;
        inset: 0;
      }

      #ui {
        position: fixed;
        top: 52px;
        right: 12px;
        width: min(360px, calc(100vw - 24px));
        max-height: calc(100vh - 64px);
        overflow-y: auto;
        padding: 13px 12px 14px;
        border: 1px solid var(--panel-border);
        border-radius: 14px;
        background: linear-gradient(165deg, var(--panel-bg), var(--panel-bg-2));
        backdrop-filter: blur(14px);
        box-shadow: 0 16px 44px rgba(0, 0, 0, 0.52), inset 0 1px 0 rgba(170, 210, 255, 0.08);
        z-index: 10;
      }

      #ui::-webkit-scrollbar {
        width: 8px;
      }

      #ui::-webkit-scrollbar-thumb {
        background: rgba(132, 183, 255, 0.34);
        border-radius: 99px;
      }

      #settingsToggle {
        position: fixed;
        right: 12px;
        top: 12px;
        z-index: 12;
        border: 1px solid rgba(157, 196, 255, 0.55);
        border-radius: 11px;
        padding: 7px 11px;
        background: linear-gradient(180deg, rgba(10, 18, 36, 0.9), rgba(10, 16, 31, 0.82));
        color: #e8f0ff;
        font-size: 12px;
        letter-spacing: 0.02em;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      }

      #ui.collapsed {
        display: none;
      }

      #ui h1 {
        margin: 0 0 11px;
        font-size: 15px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: #d4e8ff;
      }

      .row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .row + .row {
        margin-top: 8px;
      }

      .buttons button {
        flex: 1;
      }

      label {
        display: block;
        margin-top: 10px;
        font-size: 11px;
        letter-spacing: 0.03em;
        color: var(--muted);
      }

      .label-top {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        margin-bottom: 2px;
      }

      .value {
        color: var(--accent);
        font-variant-numeric: tabular-nums;
        font-size: 11px;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent-2);
      }

      button,
      select,
      input[type="checkbox"] {
        cursor: pointer;
      }

      button {
        border: 1px solid rgba(157, 196, 255, 0.45);
        border-radius: 9px;
        padding: 6px 8px;
        background: linear-gradient(180deg, rgba(67, 94, 144, 0.46), rgba(45, 67, 106, 0.38));
        color: var(--text);
        font-weight: 500;
      }

      button:hover {
        background: linear-gradient(180deg, rgba(91, 124, 181, 0.55), rgba(60, 84, 127, 0.44));
      }

      details {
        margin-top: 12px;
        border: 1px solid rgba(133, 178, 255, 0.22);
        border-radius: 10px;
        padding: 8px 9px 9px;
        background: rgba(8, 13, 26, 0.42);
      }

      summary {
        cursor: pointer;
        color: #d7e7ff;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .hint {
        margin: 7px 0 0;
        font-size: 11px;
        color: #b2c5e9;
        line-height: 1.3;
      }

      #hud {
        position: fixed;
        left: 12px;
        top: 12px;
        padding: 8px 11px;
        border-radius: 11px;
        border: 1px solid rgba(140, 182, 255, 0.32);
        background: rgba(4, 8, 18, 0.76);
        font-size: 11px;
        color: #d5e6ff;
        z-index: 10;
        font-variant-numeric: tabular-nums;
        display: flex;
        align-items: center;
        flex-wrap: nowrap;
        gap: 8px;
        max-width: calc(100vw - 410px);
        overflow-x: auto;
      }

      #hud::-webkit-scrollbar {
        height: 6px;
      }

      #hud::-webkit-scrollbar-thumb {
        background: rgba(132, 182, 255, 0.35);
        border-radius: 999px;
      }

      .hud-item {
        position: relative;
        padding-right: 11px;
        color: #d8e8ff;
        white-space: nowrap;
      }

      .hud-item:not(:last-child)::after {
        content: "";
        position: absolute;
        right: 2px;
        top: 50%;
        width: 4px;
        height: 4px;
        margin-top: -2px;
        border-radius: 999px;
        background: rgba(124, 174, 255, 0.5);
      }

      #bootWarning {
        position: fixed;
        left: 50%;
        top: 14px;
        transform: translateX(-50%);
        z-index: 20;
        max-width: min(94vw, 760px);
        padding: 9px 12px;
        border: 1px solid rgba(255, 170, 170, 0.55);
        border-radius: 10px;
        background: rgba(56, 13, 13, 0.9);
        color: #ffd4d4;
        font-size: 12px;
        line-height: 1.35;
      }

      @media (max-width: 760px) {
        #ui {
          width: calc(100vw - 18px);
          right: 9px;
          top: 46px;
          max-height: calc(100vh - 56px);
          font-size: 12px;
        }

        #settingsToggle {
          right: 9px;
          top: 9px;
        }

        #hud {
          top: 9px;
          left: 9px;
          right: 88px;
          max-width: none;
          font-size: 10px;
          gap: 6px;
        }
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <button id="settingsToggle" type="button" aria-expanded="true">Hide Settings âš™</button>

    <div id="ui">
      <h1>Kilonova Parameter Console</h1>

      <div class="row buttons">
        <button id="playPause">Pause</button>
        <button id="restart">Restart</button>
      </div>

      <label>
        <div class="label-top">
          <span>Timeline</span>
          <span class="value" id="timelineValue">0.0 s</span>
        </div>
        <input id="timeline" type="range" min="0" max="1000" step="1" value="0" />
      </label>

      <label>
        <div class="label-top">
          <span>Time Scale</span>
          <span class="value" id="timeScaleValue">1.00x</span>
        </div>
        <input id="timeScale" type="range" min="0.1" max="4" step="0.01" value="1" />
      </label>

      <details open>
        <summary>Astrophysical Parameters</summary>

        <label>
          <div class="label-top">
            <span>Neutron Star Mass m1 (Msun)</span>
            <span class="value" id="m1Value"></span>
          </div>
          <input id="m1" type="range" min="1.0" max="2.2" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Neutron Star Mass m2 (Msun)</span>
            <span class="value" id="m2Value"></span>
          </div>
          <input id="m2" type="range" min="1.0" max="2.2" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Ejecta Mass (Msun)</span>
            <span class="value" id="ejectaMassValue"></span>
          </div>
          <input id="ejectaMass" type="range" min="0.01" max="0.20" step="0.001" />
        </label>

        <label>
          <div class="label-top">
            <span>Polar Velocity (c)</span>
            <span class="value" id="polarVelValue"></span>
          </div>
          <input id="polarVel" type="range" min="0.15" max="0.45" step="0.001" />
        </label>

        <label>
          <div class="label-top">
            <span>Equatorial Velocity (c)</span>
            <span class="value" id="eqVelValue"></span>
          </div>
          <input id="eqVel" type="range" min="0.05" max="0.20" step="0.001" />
        </label>

        <label>
          <div class="label-top">
            <span>Opacity Contrast</span>
            <span class="value" id="opacityContrastValue"></span>
          </div>
          <input id="opacityContrast" type="range" min="0.5" max="2.5" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>RT Instability Strength</span>
            <span class="value" id="rtStrengthValue"></span>
          </div>
          <input id="rtStrength" type="range" min="0.0" max="3.0" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Jet Angle (deg)</span>
            <span class="value" id="jetAngleValue"></span>
          </div>
          <input id="jetAngle" type="range" min="5" max="30" step="0.1" />
        </label>

        <label>
          <div class="label-top">
            <span>Jet Intensity</span>
            <span class="value" id="jetIntensityValue"></span>
          </div>
          <input id="jetIntensity" type="range" min="0" max="3" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Remnant Luminosity</span>
            <span class="value" id="remnantLumValue"></span>
          </div>
          <input id="remnantLum" type="range" min="0" max="3" step="0.01" />
        </label>
      </details>

      <details open>
        <summary>Imaging Pipeline</summary>

        <label>
          <div class="label-top">
            <span>Bloom Strength</span>
            <span class="value" id="bloomStrengthValue"></span>
          </div>
          <input id="bloomStrength" type="range" min="0" max="3" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Chromatic Aberration</span>
            <span class="value" id="chromaticAberrationValue"></span>
          </div>
          <input id="chromaticAberration" type="range" min="0" max="2.0" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Image Sharpening</span>
            <span class="value" id="sharpenValue"></span>
          </div>
          <input id="sharpen" type="range" min="0" max="2.0" step="0.01" />
        </label>

        <label>
          <div class="label-top">
            <span>Auto Quality</span>
            <span class="value" id="autoQualityValue">On</span>
          </div>
          <input id="autoQuality" type="checkbox" checked />
        </label>

        <label>
          <div class="label-top">
            <span>Manual Quality Tier</span>
            <span class="value" id="qualityTierValue"></span>
          </div>
          <input id="qualityTier" type="range" min="0" max="3" step="1" />
        </label>
      </details>
    </div>

    <div id="hud">
      <div class="hud-item" id="hudAct"></div>
      <div class="hud-item" id="hudSim"></div>
      <div class="hud-item" id="hudPhys"></div>
      <div class="hud-item" id="hudFPS"></div>
      <div class="hud-item" id="hudQuality"></div>
      <div class="hud-item" id="hudSteps"></div>
    </div>
    <div id="bootWarning" hidden>
      Renderer did not initialize. Check browser console for errors and ensure CDN scripts can load.
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
      window.__kilonovaBooted = false;
      window.addEventListener("DOMContentLoaded", () => {
        window.setTimeout(() => {
          if (!window.__kilonovaBooted) {
            const warning = document.getElementById("bootWarning");
            if (warning) {
              warning.hidden = false;
            }
          }
        }, 1600);
      });
    </script>

    <script>
      if (!window.THREE) {
        throw new Error("THREE failed to load from CDN.");
      }

      window.__kilonovaBooted = true;
      const bootWarningEl = document.getElementById("bootWarning");
      if (bootWarningEl) {
        bootWarningEl.hidden = true;
      }

      const app = document.getElementById("app");

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      app.appendChild(renderer.domElement);
      renderer.domElement.addEventListener("contextmenu", (event) => event.preventDefault());

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x02040a);
      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 400);
      camera.position.set(31.0, 6.2, 0.0);

      class SimpleOrbitControls {
        constructor(cam, domElement) {
          this.camera = cam;
          this.domElement = domElement;
          this.target = new THREE.Vector3();
          this.enableDamping = true;
          this.dampingFactor = 0.08;
          this.minDistance = 2.8;
          this.maxDistance = 85;
          this.rotateSpeed = 0.005;
          this.zoomSpeed = 0.0018;
          this.panSpeed = 0.0018;

          this._state = 0;
          this._lastX = 0;
          this._lastY = 0;
          this._spherical = new THREE.Spherical();
          this._sphericalDelta = new THREE.Spherical(0, 0, 0);
          this._panOffset = new THREE.Vector3();
          this._offset = new THREE.Vector3();
          this._right = new THREE.Vector3();
          this._up = new THREE.Vector3();

          this._updateSphericalFromCamera();
          this._bind();
        }

        _updateSphericalFromCamera() {
          this._offset.copy(this.camera.position).sub(this.target);
          this._spherical.setFromVector3(this._offset);
          this._spherical.makeSafe();
        }

        _bind() {
          this.domElement.addEventListener("pointerdown", (e) => {
            if (e.button === 0) {
              this._state = 1;
            } else if (e.button === 2) {
              this._state = 2;
            } else {
              this._state = 0;
            }
            this._lastX = e.clientX;
            this._lastY = e.clientY;
          });

          window.addEventListener("pointerup", () => {
            this._state = 0;
          });

          window.addEventListener("pointermove", (e) => {
            if (this._state === 0) {
              return;
            }
            const dx = e.clientX - this._lastX;
            const dy = e.clientY - this._lastY;
            this._lastX = e.clientX;
            this._lastY = e.clientY;

            if (this._state === 1) {
              this._sphericalDelta.theta -= dx * this.rotateSpeed;
              this._sphericalDelta.phi -= dy * this.rotateSpeed;
            } else if (this._state === 2) {
              this.camera.updateMatrixWorld();
              const te = this.camera.matrix.elements;
              this._right.set(te[0], te[1], te[2]).normalize();
              this._up.set(te[4], te[5], te[6]).normalize();
              const dist = this.camera.position.distanceTo(this.target);
              const scale = dist * this.panSpeed;
              this._panOffset.addScaledVector(this._right, -dx * scale);
              this._panOffset.addScaledVector(this._up, dy * scale);
            }
          });

          this.domElement.addEventListener(
            "wheel",
            (e) => {
              e.preventDefault();
              this._spherical.radius *= Math.exp(e.deltaY * this.zoomSpeed);
              this._spherical.radius = Math.min(this.maxDistance, Math.max(this.minDistance, this._spherical.radius));
            },
            { passive: false }
          );
        }

        update() {
          this._spherical.theta += this._sphericalDelta.theta;
          this._spherical.phi += this._sphericalDelta.phi;
          this._spherical.makeSafe();
          this._spherical.radius = Math.min(this.maxDistance, Math.max(this.minDistance, this._spherical.radius));
          this.target.add(this._panOffset);
          this._offset.setFromSpherical(this._spherical);
          this.camera.position.copy(this.target).add(this._offset);
          this.camera.lookAt(this.target);

          if (this.enableDamping) {
            const damp = 1.0 - this.dampingFactor;
            this._sphericalDelta.theta *= damp;
            this._sphericalDelta.phi *= damp;
            this._panOffset.multiplyScalar(damp);
          } else {
            this._sphericalDelta.theta = 0;
            this._sphericalDelta.phi = 0;
            this._panOffset.set(0, 0, 0);
          }
        }
      }

      const controls = new SimpleOrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0.0, 0);

      const rtType = renderer.capabilities.isWebGL2 ? THREE.HalfFloatType : THREE.UnsignedByteType;
      const baseTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
        type: rtType,
        format: THREE.RGBAFormat,
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        depthBuffer: true,
      });

      const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const postGeometry = new THREE.PlaneGeometry(2, 2);

      function createColorTarget(width, height) {
        return new THREE.WebGLRenderTarget(width, height, {
          type: rtType,
          format: THREE.RGBAFormat,
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          depthBuffer: false,
        });
      }

      const volumeScaleByTier = [0.70, 0.62, 0.54, 0.48];
      let currentVolumeScale = volumeScaleByTier[0];
      function getVolumeDimensions(width, height) {
        return {
          w: Math.max(2, Math.floor(width * currentVolumeScale)),
          h: Math.max(2, Math.floor(height * currentVolumeScale)),
        };
      }

      const initialVolSize = getVolumeDimensions(window.innerWidth, window.innerHeight);
      const volumeCurrentTarget = createColorTarget(initialVolSize.w, initialVolSize.h);
      const volumeHistoryTargetA = createColorTarget(initialVolSize.w, initialVolSize.h);
      const volumeHistoryTargetB = createColorTarget(initialVolSize.w, initialVolSize.h);
      let volumeHistoryRead = volumeHistoryTargetA;
      let volumeHistoryWrite = volumeHistoryTargetB;

      function swapVolumeHistoryTargets() {
        const temp = volumeHistoryRead;
        volumeHistoryRead = volumeHistoryWrite;
        volumeHistoryWrite = temp;
      }

      const fullscreenVertex = /* glsl */ `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = vec4(position.xy, 0.0, 1.0);
        }
      `;

      const volumeShader = {
        uniforms: {
          uResolution: { value: new THREE.Vector2(initialVolSize.w, initialVolSize.h) },
          uCamPos: { value: new THREE.Vector3() },
          uInvProj: { value: new THREE.Matrix4() },
          uInvView: { value: new THREE.Matrix4() },
          uTime: { value: 0 },
          uAct: { value: 1.0 },
          uAct2Progress: { value: 0.0 },
          uAct3Progress: { value: 0.0 },
          uDays: { value: 0.03 },
          uCollisionFlash: { value: 0.0 },
          uEnergyScale: { value: 1.0 },
          uEjectaMass: { value: 0.05 },
          uPolarVel: { value: 0.30 },
          uEqVel: { value: 0.10 },
          uOpacityContrast: { value: 1.4 },
          uRTStrength: { value: 1.1 },
          uJetAngle: { value: 9.5 },
          uJetIntensity: { value: 1.8 },
          uRemnantLum: { value: 1.1 },
          uSteps: { value: 140.0 },
          uNoiseOctaves: { value: 5.0 },
          uStepScale: { value: 1.0 },
          uNoiseScale: { value: 1.0 },
        },
        vertexShader: fullscreenVertex,
        fragmentShader: /* glsl */ `
          precision highp float;

          varying vec2 vUv;
          uniform vec2 uResolution;
          uniform vec3 uCamPos;
          uniform mat4 uInvProj;
          uniform mat4 uInvView;
          uniform float uTime;
          uniform float uAct;
          uniform float uAct2Progress;
          uniform float uAct3Progress;
          uniform float uDays;
          uniform float uCollisionFlash;
          uniform float uEnergyScale;
          uniform float uEjectaMass;
          uniform float uPolarVel;
          uniform float uEqVel;
          uniform float uOpacityContrast;
          uniform float uRTStrength;
          uniform float uJetAngle;
          uniform float uJetIntensity;
          uniform float uRemnantLum;
          uniform float uSteps;
          uniform float uNoiseOctaves;
          uniform float uStepScale;
          uniform float uNoiseScale;

          #define MAX_STEPS 144

          float hash11(float p) {
            p = fract(p * 0.1031);
            p *= p + 33.33;
            p *= p + p;
            return fract(p);
          }

          float hash31(vec3 p3) {
            p3 = fract(p3 * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
          }

          float noise3(vec3 p) {
            vec3 i = floor(p);
            vec3 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);

            float n000 = hash31(i + vec3(0.0, 0.0, 0.0));
            float n100 = hash31(i + vec3(1.0, 0.0, 0.0));
            float n010 = hash31(i + vec3(0.0, 1.0, 0.0));
            float n110 = hash31(i + vec3(1.0, 1.0, 0.0));
            float n001 = hash31(i + vec3(0.0, 0.0, 1.0));
            float n101 = hash31(i + vec3(1.0, 0.0, 1.0));
            float n011 = hash31(i + vec3(0.0, 1.0, 1.0));
            float n111 = hash31(i + vec3(1.0, 1.0, 1.0));

            float nx00 = mix(n000, n100, f.x);
            float nx10 = mix(n010, n110, f.x);
            float nx01 = mix(n001, n101, f.x);
            float nx11 = mix(n011, n111, f.x);

            float nxy0 = mix(nx00, nx10, f.y);
            float nxy1 = mix(nx01, nx11, f.y);

            return mix(nxy0, nxy1, f.z);
          }

          float fbm(vec3 p, float octaves) {
            float sum = 0.0;
            float amp = 0.5;
            float freq = 1.0;
            for (int i = 0; i < 6; i++) {
              if (float(i) >= octaves) {
                break;
              }
              sum += amp * noise3(p * freq);
              freq *= 2.0;
              amp *= 0.5;
            }
            return sum;
          }

          vec3 kelvinToRGB(float tempK) {
            float t = clamp(tempK, 1200.0, 40000.0) / 100.0;
            float r;
            float g;
            float b;

            if (t <= 66.0) {
              r = 1.0;
              g = clamp(0.39008158 * log(max(t, 1e-3)) - 0.63184144, 0.0, 1.0);
            } else {
              float tt = t - 60.0;
              r = clamp(1.29293619 * pow(tt, -0.13320476), 0.0, 1.0);
              g = clamp(1.12989086 * pow(tt, -0.07551485), 0.0, 1.0);
            }

            if (t >= 66.0) {
              b = 1.0;
            } else if (t <= 19.0) {
              b = 0.0;
            } else {
              b = clamp(0.54320679 * log(t - 10.0) - 1.19625409, 0.0, 1.0);
            }

            return vec3(r, g, b);
          }

          vec2 raySphere(vec3 ro, vec3 rd, float radius) {
            float b = dot(ro, rd);
            float c = dot(ro, ro) - radius * radius;
            float h = b * b - c;
            if (h < 0.0) {
              return vec2(1e9, -1e9);
            }
            h = sqrt(h);
            return vec2(-b - h, -b + h);
          }

          void main() {
            vec3 accum = vec3(0.0);

            if (uAct >= 1.5) {
              vec2 ndc = vUv * 2.0 - 1.0;
              vec4 clip = vec4(ndc, 1.0, 1.0);
              vec4 view = uInvProj * clip;
              view /= max(view.w, 1e-6);
              vec3 rd = normalize((uInvView * vec4(view.xyz, 0.0)).xyz);
              vec3 ro = uCamPos;

              float boundRadius = (17.0 + 7.5 * uEnergyScale);
              vec2 hit = raySphere(ro, rd, boundRadius);
              if (hit.x <= hit.y) {
                float distToCenter = length(vUv - vec2(0.5));
                float centerFocus = 1.0 - smoothstep(0.12, 0.86, distToCenter);
                float peripheryFactor = mix(0.42, 1.0, centerFocus);
                float earlyBurst = uAct < 2.5 ? (0.86 + 0.78 * (1.0 - uAct2Progress)) : (1.0 + 0.40 * exp(-uAct3Progress * 5.0));
                float localSteps = floor(max(20.0, uSteps * uStepScale * peripheryFactor * earlyBurst));
                float localOctaves = max(2.0, floor(uNoiseOctaves * uNoiseScale * mix(0.55, 1.0, centerFocus)));

                float tNear = max(hit.x, 0.0);
                float tFar = hit.y;
                float totalDist = max(1e-4, tFar - tNear);
                float dt = totalDist / max(1.0, localSteps);
                float jitter = (hash11(dot(vUv, vec2(113.17, 91.73)) + uTime) - 0.5) * dt;

                float evo = clamp(uAct3Progress, 0.0, 1.0);
                float mNorm = clamp((uEjectaMass - 0.01) / 0.19, 0.0, 1.0);
                float densityScale = mix(0.6, 2.0, mNorm);
                float opacityScale = mix(0.7, 2.6, mNorm);
                float vpScale = uPolarVel / 0.30;
                float veScale = uEqVel / 0.10;

                float Rp = mix(1.1, 13.2 * uEnergyScale * vpScale, pow(evo, 0.78));
                float Re = mix(0.95, 9.1 * uEnergyScale * veScale, pow(evo, 0.88));
                float thickP = mix(0.32, 1.05, evo);
                float thickE = mix(0.42, 1.42, evo);
                float Rrs = mix(Re, Rp, 0.62);

                float tDays = max(uDays, 0.03);
                float heatNorm = clamp(pow(tDays, -1.3) / 95.0, 0.06, 1.2);
                float collisionCore = uAct < 2.5 ? 1.0 - smoothstep(0.55, 1.0, uAct2Progress) : exp(-evo * 6.5);
                float viewJetAlign = abs(rd.z);
                float promptBeam = pow(viewJetAlign, 2.6);
                float promptVisibility = mix(0.44, 1.0, promptBeam);
                float jetLaunch = uAct < 2.5 ? (0.40 + 0.60 * uAct2Progress) : (1.0 - 0.35 * smoothstep(0.0, 1.0, evo));
                float jetPersist = uAct < 2.5 ? 1.0 : (0.82 + 0.18 * exp(-evo * 2.6));
                float jetStrength = uJetIntensity * jetLaunch * jetPersist * (1.20 + 0.55 * collisionCore);

                float phaseBlue = 1.0 - smoothstep(0.06, 1.6, tDays);
                float phasePurple = smoothstep(0.05, 0.9, tDays) * (1.0 - smoothstep(2.2, 5.8, tDays));
                float phaseRed = smoothstep(0.5, 8.5, tDays);
                float phaseCloudEarly = smoothstep(0.03, 0.16, tDays) * (1.0 - smoothstep(0.9, 3.2, tDays));
                float phaseNebula = smoothstep(0.10, 1.8, tDays) * (0.60 + 0.40 * smoothstep(0.22, 0.75, evo));

                float Tpolar = mix(12500.0, 4200.0, smoothstep(0.06, 9.0, tDays));
                float Teq = mix(7200.0, 2400.0, smoothstep(0.18, 15.0, tDays));
                float Tcocoon = mix(11000.0, 3800.0, smoothstep(0.08, 7.0, tDays));
                float TcloudEarly = mix(11500.0, 6200.0, smoothstep(0.04, 1.8, tDays));
                float TcloudLate = mix(9000.0, 4300.0, smoothstep(0.2, 10.0, tDays));

                vec3 colorJet = vec3(0.67, 0.84, 1.35);
                vec3 colorJetHot = vec3(1.02, 1.28, 1.86);
                vec3 colPolar = kelvinToRGB(Tpolar) * mix(1.15, 1.0, phaseRed);
                vec3 colEq = mix(kelvinToRGB(Teq), vec3(0.98, 0.53, 0.26), 0.45 * phaseRed);
                vec3 colRS = mix(kelvinToRGB(9500.0), vec3(1.0, 0.64, 0.76), 0.30 * phaseRed);
                vec3 colRT = mix(vec3(0.90, 0.64, 1.04), vec3(1.00, 0.56, 0.31), smoothstep(0.45, 1.0, evo));
                vec3 colCocoon = mix(kelvinToRGB(Tcocoon), vec3(0.84, 0.62, 1.06), 0.28 + 0.30 * phasePurple);
                vec3 colInnerCloud = mix(kelvinToRGB(TcloudEarly), vec3(0.78, 0.96, 1.36), 0.30 * phasePurple);
                vec3 colNestedShell = mix(kelvinToRGB(TcloudLate), vec3(0.97, 0.58, 0.42), 0.42 * phaseRed);
                vec3 colNebulaCloud = mix(kelvinToRGB(TcloudLate + 700.0), vec3(0.76, 0.95, 1.28), 0.46);

                float trans = 1.0;
                float t = tNear + jitter;

                for (int i = 0; i < MAX_STEPS; i++) {
                  if (float(i) >= localSteps || t > tFar) {
                    break;
                  }

                  vec3 p = ro + rd * t;
                  float r = length(p);
                  vec3 n = p / max(r, 1e-5);

                  float pole = pow(abs(n.z), 3.7);
                  float equa = pow(max(0.0, 1.0 - abs(n.z)), 2.05);

                  float rhoP = exp(-pow((r - Rp) / thickP, 2.0)) * pole;
                  float rhoE = exp(-pow((r - Re) / thickE, 2.0)) * equa;

                  float rsThickness = mix(0.18, 0.45, evo);
                  float rhoRS = exp(-pow((r - Rrs) / rsThickness, 2.0)) * mix(0.75 * equa, 0.65 * pole, 0.4);

                  float rhoRT = 0.0;
                  float rhoJet = 0.0;
                  float rhoCocoon = 0.0;
                  float rhoForward = 0.0;
                  float rhoInnerCloud = 0.0;
                  float rhoNestedShell = 0.0;
                  float rhoShockCloud = 0.0;
                  float rhoNebula = 0.0;
                  float nestedPhase = smoothstep(0.06, 1.0, evo);
                  float innerR = mix(0.95, Re * 0.60 + 1.0, nestedPhase);
                  float innerW = 0.30 + 0.46 * nestedPhase;
                  float rhoInnerBase = exp(-pow((r - innerR) / innerW, 2.0)) * (0.35 + 0.65 * (1.0 - smoothstep(0.78, 1.0, evo)));
                  float shockCloudR = mix(0.68, Re * 0.86 + 0.55, smoothstep(0.02, 0.55, evo));
                  float shockCloudW = 0.34 + 0.58 * smoothstep(0.02, 0.70, evo);
                  float antiJet = pow(max(0.0, 1.0 - abs(n.z)), 1.05);
                  float rhoShockCloudBase = exp(-pow((r - shockCloudR) / shockCloudW, 2.0)) * antiJet * phaseCloudEarly;
                  float nestedR = Rp * (1.20 + 0.42 * nestedPhase);
                  float nestedW = 0.30 + 0.45 * nestedPhase;
                  float rhoNestedBase = exp(-pow((r - nestedR) / nestedW, 2.0)) * smoothstep(0.26, 1.0, evo);
                  float rhoNestedLat = exp(-pow((abs(n.z) - 0.72) / (0.16 + 0.08 * nestedPhase), 2.0));
                  float rhoNestedBroad = rhoNestedBase * (0.22 + 0.78 * rhoNestedLat);
                  float nebulaPhaseLocal = smoothstep(0.10, 1.0, evo);
                  float nebulaR = mix(Re * 0.58 + 0.45, Re * (0.95 + 0.20 * nebulaPhaseLocal), nebulaPhaseLocal);
                  float nebulaW = 0.55 + 0.95 * nebulaPhaseLocal;
                  float rhoNebulaBase = exp(-pow((r - nebulaR) / nebulaW, 2.0)) * (0.12 + 0.88 * phaseNebula);

                  float coarseShell = rhoP + rhoE + rhoRS + 0.35 * rhoInnerBase + 0.70 * rhoShockCloudBase + 0.55 * rhoNestedBroad + 0.65 * rhoNebulaBase;
                  float stepMul = 1.0;
                  if (coarseShell < 0.0018) {
                    stepMul = 1.58;
                  }

                  if (coarseShell > 0.004 || abs(n.z) > 0.62) {
                    float rtLayer = exp(-pow((r - mix(Re, Rp, 0.52)) / (thickE * 1.1 + 0.08), 2.0));
                    float rtGrowth = pow(evo, 1.55) * uRTStrength;
                    vec3 warpP = p * 0.85 + vec3(0.0, 0.0, uTime * 0.23);
                    float warp = fbm(warpP * 0.95, localOctaves);
                    float fingers = smoothstep(0.50, 0.89, fbm(warpP * 2.15 + warp * 2.3 * n, localOctaves));
                    float phi = atan(n.y, n.x);
                    float branch = 0.5 + 0.5 * sin(phi * 13.0 + uTime * 0.74 + warp * 5.3);
                    rhoRT = rtLayer * fingers * (0.35 + 1.75 * branch) * rtGrowth;

                    float angle = radians(max(3.0, uJetAngle));
                    float axisR = length(p.xy);
                    float az = abs(p.z);
                    float jetLengthRaw = mix(4.2 + 4.6 * uEnergyScale, Rp * (3.10 + 0.38 * collisionCore), smoothstep(0.0, 0.40, evo));
                    float jetLength = min(jetLengthRaw, boundRadius * 0.88);
                    float beamT = clamp(az / max(jetLength, 1e-3), 0.0, 1.0);
                    float theta = atan(axisR, max(az, 1e-4));
                    float thetaCore = max(angle * 0.70, radians(2.0));
                    float gaussCore = exp(-0.5 * pow(theta / thetaCore, 2.0));
                    float wing = pow(1.0 + pow(theta / (thetaCore * 1.45), 2.0), -1.15);
                    float structuredJet = clamp(gaussCore + 0.34 * wing, 0.0, 1.55);
                    float collimation = mix(0.16, 0.52, smoothstep(0.0, 0.75, beamT));
                    float coreWidth = 0.065 + az * tan(angle * collimation);
                    float sheathWidth = coreWidth * (2.2 + 0.7 * (1.0 - beamT));

                    float spine = exp(-pow(axisR / max(coreWidth, 1e-4), 2.0));
                    float sheath = max(exp(-pow(axisR / max(sheathWidth, 1e-4), 2.0)) - spine, 0.0);
                    float along = smoothstep(0.12, 1.0, az) * (1.0 - smoothstep(jetLength, jetLength + (1.4 + 0.8 * evo), az));
                    float jetNoise = 0.58 + 0.42 * fbm(vec3(axisR * 3.1, az * 1.4 + uTime * 0.9, uTime * 0.65), localOctaves);
                    float filament = 0.68 + 0.32 * sin(az * 8.0 - uTime * 3.2 + phi * 4.0);
                    float shockTrain = 0.60 + 0.40 * pow(0.5 + 0.5 * sin(beamT * 36.0 - uTime * 5.2), 3.0);
                    float jetBeam = (spine * (1.0 + 0.22 * filament) + sheath * 0.55) * along * jetNoise * shockTrain;

                    float headR = 0.85 + 1.10 * smoothstep(0.0, 1.0, evo);
                    float headNoise = 0.82 + 0.18 * fbm(vec3(axisR * 2.2, az * 0.9 + uTime * 0.28, 1.7), localOctaves);
                    float head = exp(-pow((az - jetLength) / (0.34 + 0.48 * evo), 2.0)) * exp(-pow(axisR / headR, 2.0)) * headNoise;
                    float hotspot = exp(-pow((az - jetLength) / (0.18 + 0.20 * evo), 2.0)) * exp(-pow(axisR / (0.36 + 0.28 * evo), 2.0)) * headNoise;

                    float cocoonRadius = az * tan(angle * 1.45) + 0.22;
                    float cocoonShell = exp(-pow((axisR - cocoonRadius) / (0.20 + 0.30 * evo), 2.0)) * smoothstep(0.35, jetLength * 1.3, az);
                    float cocoonFill = exp(-pow(axisR / (cocoonRadius * (1.25 + 0.30 * collisionCore) + 0.35), 2.0)) * smoothstep(0.4, jetLength * 1.25, az);
                    float cocoonWarp = fbm(vec3(axisR * 1.8, az * 0.9 + uTime * 0.21, uTime * 0.35), localOctaves);
                    float cocoonTurb = 0.70 + 0.30 * sin(cocoonWarp * 8.0 + az * 2.4 - uTime * 0.5);
                    float breakoutRadius = headR * (1.35 + 0.70 * smoothstep(0.0, 1.0, evo));
                    float cocoonBreakout = exp(-pow((az - (jetLength + 0.4)) / (0.40 + 0.55 * evo), 2.0)) * exp(-pow((axisR - breakoutRadius) / (0.34 + 0.40 * evo), 2.0));

                    float jetTailEnd = min(boundRadius * 1.02, jetLength + 11.0 + Rp * 0.22);
                    float jetCut = 1.0 - smoothstep(jetLength + 3.6, jetTailEnd, az);
                    rhoJet = (jetBeam + 1.70 * head + 2.10 * hotspot) * jetStrength * jetCut * structuredJet;
                    rhoCocoon = (1.10 * cocoonShell + 0.70 * cocoonFill + 1.10 * head + 0.95 * cocoonBreakout) * cocoonTurb * (0.90 + 0.82 * collisionCore) * clamp(jetStrength, 0.0, 3.2);
                  }

                  float rhoAmbient = exp(-pow((r - Rp * 1.16) / (thickP * 0.9 + 0.18), 2.0)) * 0.22;
                  float localOctFast = max(2.0, localOctaves - 1.0);
                  if (rhoInnerBase > 0.010 || rhoShockCloudBase > 0.008 || rhoNestedBroad > 0.010 || rhoNebulaBase > 0.008) {
                    float clumpNoise = fbm(p * 2.55 + vec3(0.0, 0.0, uTime * 0.20), localOctFast);
                    float clumpCells = 0.5 + 0.5 * sin((p.x + p.y + p.z) * 4.5 + uTime * 2.1 + clumpNoise * 8.0);
                    float clumpMask = smoothstep(0.45, 0.88, clumpNoise) * (0.45 + 0.55 * clumpCells);
                    rhoInnerCloud = rhoInnerBase * (0.28 + 1.55 * clumpMask);
                    rhoShockCloud = rhoShockCloudBase * (0.25 + 1.90 * clumpMask);

                    float axisRSoft = length(p.xy);
                    float shellWarp = 0.72 + 0.28 * fbm(vec3(axisRSoft * 1.35, abs(p.z) * 0.85 + uTime * 0.12, uTime * 0.16), localOctFast);
                    rhoNestedShell = rhoNestedBroad * shellWarp;

                    float nebNoise = fbm(p * 2.90 + vec3(uTime * 0.14, -uTime * 0.11, uTime * 0.09), localOctFast);
                    float nebCells = noise3(p * 7.20 + vec3(uTime * 0.21));
                    float nebMask = smoothstep(0.46, 0.90, nebNoise + 0.55 * nebCells);
                    float puffBand = 0.58 + 0.42 * sin((r - nebulaR) * 18.0 + nebNoise * 10.0 - uTime * 1.1);
                    rhoNebula = rhoNebulaBase * (0.20 + 2.20 * nebMask * puffBand);
                  }

                  float forwardR = Rp * (1.08 + 0.46 * smoothstep(0.02, 1.0, evo));
                  float forwardShell = exp(-pow((r - forwardR) / (0.24 + 0.42 * evo), 2.0));
                  float forwardAniso = mix(pow(abs(n.z), 1.30), 1.0, 0.38);
                  rhoForward = forwardShell * forwardAniso * smoothstep(0.04, 0.98, evo) * (0.85 + 0.55 * collisionCore);

                  float eqEmergence = smoothstep(0.20, 0.95, evo);
                  float polarFade = 1.0 - smoothstep(0.28, 0.98, evo);
                  float jetCool = smoothstep(0.06, 1.0, evo);
                  float daySoften = smoothstep(0.05, 4.5, tDays);
                  vec3 colJetSynch = mix(vec3(0.95, 1.12, 1.74), vec3(0.58, 0.80, 1.24), daySoften);
                  vec3 colJetMix = mix(mix(colorJet, colorJetHot, clamp(0.8 * collisionCore + 0.2 * (1.0 - evo), 0.0, 1.0)), colJetSynch, 0.58 * jetCool);
                  vec3 colCocoonMix = mix(colCocoon, vec3(0.69, 0.78, 1.16), 0.36 * daySoften);

                  float boundaryP = exp(-pow((r - Rp) / (thickP * 0.55 + 1e-3), 2.0));
                  float boundaryE = exp(-pow((r - Re) / (thickE * 0.55 + 1e-3), 2.0));
                  float shockBoost = 1.0 + 1.4 * (boundaryP * boundaryE + 0.45 * boundaryP);

                  vec3 emiss = vec3(0.0);
                  emiss += rhoP * (1.65 * polarFade + 0.45) * colPolar;
                  emiss += rhoE * (0.45 + 1.15 * eqEmergence) * colEq;
                  emiss += rhoRS * 1.95 * colRS;
                  emiss += rhoRT * 1.20 * colRT;
                  emiss += rhoJet * (2.25 + 0.75 * collisionCore) * colJetMix;
                  emiss += rhoCocoon * (1.15 + 1.10 * collisionCore) * colCocoonMix;
                  emiss += rhoInnerCloud * (1.10 + 0.62 * phaseBlue) * colInnerCloud;
                  emiss += rhoShockCloud * (1.20 + 0.78 * phaseBlue) * colInnerCloud;
                  emiss += rhoNestedShell * (0.95 + 0.40 * collisionCore) * colNestedShell;
                  emiss += rhoNebula * (1.05 + 0.55 * phaseBlue) * colNebulaCloud;
                  emiss += rhoForward * vec3(0.66, 0.86, 1.25);
                  emiss += rhoAmbient * 0.55 * vec3(0.92, 0.64, 0.86);
                  emiss *= heatNorm * shockBoost;
                  float nebulaNonThermal = (0.14 + 0.26 * exp(-tDays / 9.0)) * phaseNebula;
                  emiss += rhoNebula * nebulaNonThermal * colNebulaCloud * (0.95 + 0.35 * collisionCore);

                  float corePulse = 0.68 + 0.32 * sin(uTime * 9.0);
                  float coreGlow = exp(-pow(r / 0.36, 2.0)) * (0.95 + 0.8 * corePulse) * uRemnantLum;
                  emiss += coreGlow * vec3(2.0, 1.7, 2.4);

                  float blastHalo = 0.0;
                  if (uAct < 2.5) {
                    float blastR = 1.5 + 8.0 * uAct2Progress;
                    float blast = exp(-pow((r - blastR) / (0.22 + 0.35 * uAct2Progress), 2.0));
                    float flashAniso = mix(0.50, 1.0, pow(abs(n.z), 1.6));
                    blastHalo = blast * uCollisionFlash * flashAniso * promptVisibility;
                    emiss += blastHalo * vec3(4.2, 3.4, 3.2);
                    emiss += exp(-pow(r / 1.15, 2.0)) * uCollisionFlash * (0.45 + 0.55 * promptVisibility) * vec3(5.9, 5.3, 6.9);
                  } else {
                    float earlyShock = exp(-evo * 7.0);
                    float blastR3 = mix(2.1, Rp * 0.95, smoothstep(0.0, 0.30, evo));
                    blastHalo = exp(-pow((r - blastR3) / (0.28 + 0.46 * evo), 2.0)) * earlyShock * (0.75 + 0.5 * uEnergyScale) * (0.55 + 0.45 * promptVisibility);
                    emiss += blastHalo * vec3(1.4, 1.1, 1.7);
                  }

                  float sigma = (rhoP * 0.72 + rhoE * 1.18 * uOpacityContrast + rhoRS * 0.9 + rhoRT * 1.1 + rhoJet * 0.33 + rhoCocoon * 0.52 + rhoInnerCloud * 0.42 + rhoShockCloud * 0.52 + rhoNestedShell * 0.48 + rhoNebula * 0.56 + rhoForward * 0.28 + rhoAmbient * 0.4 + blastHalo * 0.3);
                  sigma *= opacityScale * densityScale * 0.34;

                  float dtEff = dt * stepMul;
                  if (sigma < 0.0015 && coarseShell < 0.0024 && (rhoJet + rhoCocoon + rhoInnerCloud + rhoShockCloud + rhoNestedShell + rhoNebula) < 0.0018) {
                    t += dtEff;
                    continue;
                  }

                  float alpha = 1.0 - exp(-sigma * dtEff);
                  vec3 contrib = emiss * alpha;
                  accum += trans * contrib;
                  trans *= (1.0 - alpha);
                  t += dtEff;

                  if (trans < 0.01) {
                    break;
                  }
                }
              }
            }

            gl_FragColor = vec4(max(accum, vec3(0.0)), 1.0);
          }
        `,
      };

      const temporalShader = {
        uniforms: {
          tCurrent: { value: volumeCurrentTarget.texture },
          tHistory: { value: volumeHistoryRead.texture },
          uHistoryBlend: { value: 0.0 },
          uHistoryReset: { value: 1.0 },
          uTemporalClamp: { value: 0.55 },
        },
        vertexShader: fullscreenVertex,
        fragmentShader: /* glsl */ `
          precision highp float;
          varying vec2 vUv;
          uniform sampler2D tCurrent;
          uniform sampler2D tHistory;
          uniform float uHistoryBlend;
          uniform float uHistoryReset;
          uniform float uTemporalClamp;

          void main() {
            vec3 current = texture2D(tCurrent, vUv).rgb;
            vec3 history = texture2D(tHistory, vUv).rgb;

            vec3 low = current - vec3(uTemporalClamp);
            vec3 high = current + vec3(uTemporalClamp);
            history = clamp(history, low, high);

            float blend = clamp(uHistoryBlend, 0.0, 0.98);
            vec3 accumulated = mix(current, history, blend);
            vec3 outColor = mix(accumulated, current, step(0.5, uHistoryReset));
            gl_FragColor = vec4(max(outColor, vec3(0.0)), 1.0);
          }
        `,
      };

      const compositeShader = {
        uniforms: {
          tBase: { value: baseTarget.texture },
          tVolume: { value: volumeHistoryRead.texture },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uVolumeResolution: { value: new THREE.Vector2(initialVolSize.w, initialVolSize.h) },
          uAct: { value: 1.0 },
          uAct2Progress: { value: 0.0 },
          uBloomStrength: { value: 1.25 },
          uChromAb: { value: 0.08 },
          uSharpen: { value: 0.65 },
          uGRBDirect: { value: 0.0 },
          uGRBCocoon: { value: 0.0 },
          uGRBShockR: { value: 0.0 },
          uGRBCenter: { value: new THREE.Vector2(0.5, 0.5) },
          uGRBAxisDir: { value: new THREE.Vector2(1.0, 0.0) },
          uStarScreen1: { value: new THREE.Vector2(-10, -10) },
          uStarScreen2: { value: new THREE.Vector2(-10, -10) },
          uStarVis1: { value: 0.0 },
          uStarVis2: { value: 0.0 },
        },
        vertexShader: fullscreenVertex,
        fragmentShader: /* glsl */ `
          precision highp float;
          varying vec2 vUv;
          uniform sampler2D tBase;
          uniform sampler2D tVolume;
          uniform vec2 uResolution;
          uniform vec2 uVolumeResolution;
          uniform float uAct;
          uniform float uAct2Progress;
          uniform float uBloomStrength;
          uniform float uChromAb;
          uniform float uSharpen;
          uniform float uGRBDirect;
          uniform float uGRBCocoon;
          uniform float uGRBShockR;
          uniform vec2 uGRBCenter;
          uniform vec2 uGRBAxisDir;
          uniform vec2 uStarScreen1;
          uniform vec2 uStarScreen2;
          uniform float uStarVis1;
          uniform float uStarVis2;

          vec3 sampleBase(vec2 uv) {
            return texture2D(tBase, clamp(uv, 0.0, 1.0)).rgb;
          }

          vec3 sampleVolume(vec2 uv) {
            vec2 texel = 1.0 / uVolumeResolution;
            vec3 c = texture2D(tVolume, clamp(uv, 0.0, 1.0)).rgb;
            vec3 n0 = texture2D(tVolume, clamp(uv + vec2(texel.x, 0.0), 0.0, 1.0)).rgb;
            vec3 n1 = texture2D(tVolume, clamp(uv - vec2(texel.x, 0.0), 0.0, 1.0)).rgb;
            vec3 n2 = texture2D(tVolume, clamp(uv + vec2(0.0, texel.y), 0.0, 1.0)).rgb;
            vec3 n3 = texture2D(tVolume, clamp(uv - vec2(0.0, texel.y), 0.0, 1.0)).rgb;
            vec3 d0 = texture2D(tVolume, clamp(uv + vec2(texel.x, texel.y), 0.0, 1.0)).rgb;
            vec3 d1 = texture2D(tVolume, clamp(uv + vec2(-texel.x, texel.y), 0.0, 1.0)).rgb;
            vec3 d2 = texture2D(tVolume, clamp(uv + vec2(texel.x, -texel.y), 0.0, 1.0)).rgb;
            vec3 d3 = texture2D(tVolume, clamp(uv + vec2(-texel.x, -texel.y), 0.0, 1.0)).rgb;
            vec3 tent = c * 0.36 + (n0 + n1 + n2 + n3) * 0.12 + (d0 + d1 + d2 + d3) * 0.04;
            vec3 detail = c - (n0 + n1 + n2 + n3) * 0.25;
            return max(tent + detail * 0.28, vec3(0.0));
          }

          vec3 starAura(vec2 uv, vec2 center, float vis) {
            vec2 d = uv - center;
            float r2 = dot(d, d);
            float core = exp(-r2 * 1250.0);
            float halo = exp(-r2 * 220.0);
            float outer = exp(-r2 * 60.0);
            float streak = exp(-abs(d.y) * 240.0) * exp(-abs(d.x) * 8.0);
            vec3 tint = vec3(0.72, 0.95, 1.55);
            return vis * tint * (core * 0.95 + halo * 0.40 + outer * 0.12 + streak * 0.34);
          }

          void main() {
            vec2 center = vec2(0.5);
            vec2 dirToCenter = (vUv - center);
            float distToCenter = length(dirToCenter);
            vec2 nDir = distToCenter > 1e-5 ? dirToCenter / distToCenter : vec2(0.0, 0.0);

            float ab = uChromAb * 0.0024 * (0.4 + distToCenter * 1.35);
            vec3 caColor;
            caColor.r = sampleBase(vUv + nDir * ab).r;
            caColor.g = sampleBase(vUv).g;
            caColor.b = sampleBase(vUv - nDir * ab).b;

            vec2 texel = 1.0 / uResolution;
            vec3 b0 = sampleBase(vUv + vec2(texel.x, 0.0));
            vec3 b1 = sampleBase(vUv - vec2(texel.x, 0.0));
            vec3 b2 = sampleBase(vUv + vec2(0.0, texel.y));
            vec3 b3 = sampleBase(vUv - vec2(0.0, texel.y));
            vec3 blurBase = (b0 + b1 + b2 + b3) * 0.25;
            vec3 sceneColor = max(caColor + (caColor - blurBase) * (uSharpen * 1.25), vec3(0.0));

            vec3 volumeColor = sampleVolume(vUv);
            vec3 outColor = sceneColor + volumeColor;
            outColor += starAura(vUv, uStarScreen1, uStarVis1);
            outColor += starAura(vUv, uStarScreen2, uStarVis2);

            vec2 d = vUv - uGRBCenter;
            float r = length(d);
            vec2 axis = normalize(uGRBAxisDir + vec2(1e-5, 0.0));
            vec2 nAxis = vec2(-axis.y, axis.x);
            float along = dot(d, axis);
            float across = dot(d, nAxis);

            float promptCore = exp(-r * r * 220.0);
            float promptLine = exp(-abs(across) * 230.0) * exp(-abs(along) * 3.2);
            float promptHalo = exp(-r * r * 20.0);
            vec3 promptCol = vec3(1.02, 1.10, 1.35);
            outColor += uGRBDirect * promptCol * (2.0 * promptCore + 1.65 * promptLine + 0.30 * promptHalo);

            float shockW = 0.020 + 0.045 * uGRBCocoon;
            float shockRing = exp(-pow((r - uGRBShockR) / max(shockW, 1e-4), 2.0));
            float cocoonHaze = exp(-r * r * 8.0);
            vec3 cocoonCol = vec3(0.62, 0.75, 1.20);
            outColor += uGRBCocoon * cocoonCol * (1.2 * shockRing + 0.22 * cocoonHaze);

            float luminance = dot(outColor, vec3(0.2126, 0.7152, 0.0722));
            float bloomMask = smoothstep(0.50, 1.7, luminance);
            float act2BloomSupp = uAct < 2.5 ? (0.72 + 0.28 * uAct2Progress) : 1.0;
            vec3 bloomColor = (blurBase + volumeColor * (0.23 * act2BloomSupp + 0.10)) * bloomMask * (0.9 * uBloomStrength);
            outColor += bloomColor + volumeColor * ((0.13 + 0.07 * act2BloomSupp) * uBloomStrength);

            gl_FragColor = vec4(max(outColor, vec3(0.0)), 1.0);
          }
        `,
      };

      const volumeMaterial = new THREE.ShaderMaterial({
        uniforms: volumeShader.uniforms,
        vertexShader: volumeShader.vertexShader,
        fragmentShader: volumeShader.fragmentShader,
        depthTest: false,
        depthWrite: false,
      });
      const temporalMaterial = new THREE.ShaderMaterial({
        uniforms: temporalShader.uniforms,
        vertexShader: temporalShader.vertexShader,
        fragmentShader: temporalShader.fragmentShader,
        depthTest: false,
        depthWrite: false,
      });
      const compositeMaterial = new THREE.ShaderMaterial({
        uniforms: compositeShader.uniforms,
        vertexShader: compositeShader.vertexShader,
        fragmentShader: compositeShader.fragmentShader,
        depthTest: false,
        depthWrite: false,
      });

      const volumeScene = new THREE.Scene();
      const temporalScene = new THREE.Scene();
      const compositeScene = new THREE.Scene();
      volumeScene.add(new THREE.Mesh(postGeometry, volumeMaterial));
      temporalScene.add(new THREE.Mesh(postGeometry, temporalMaterial));
      compositeScene.add(new THREE.Mesh(postGeometry, compositeMaterial));

      const starVertexShader = /* glsl */ `
        uniform vec3 uDeformDir;
        uniform float uDeform;
        uniform float uTime;
        varying vec3 vWorldPos;
        varying vec3 vWorldNormal;
        varying vec3 vLocalPos;

        void main() {
          vec3 p = position;
          vec3 d = normalize(uDeformDir + vec3(1e-6));
          float tidal = clamp(uDeform, 0.0, 1.0);

          float par = dot(p, d);
          vec3 pPar = d * par;
          vec3 pPerp = p - pPar;

          // Prolate deformation expected from tidal forces near contact.
          float stretch = 1.0 + tidal * 0.82;
          float squash = 1.0 - tidal * 0.26;
          p = pPar * stretch + pPerp * squash;

          // Slight Roche-like cusp toward the companion-facing hemisphere.
          float face = smoothstep(-0.08, 1.0, par);
          p += d * face * tidal * 0.12;

          // Low-amplitude surface agitation for plasma-like granulation.
          p += normal * (0.005 + 0.010 * tidal) * sin(uTime * 1.5 + position.y * 14.0 + position.x * 6.0);

          vec4 wp = modelMatrix * vec4(p, 1.0);
          vWorldPos = wp.xyz;
          vWorldNormal = normalize(mat3(modelMatrix) * normalize(p));
          vLocalPos = normalize(p);
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `;

      const starFragmentShader = /* glsl */ `
        precision highp float;
        uniform vec3 uCamPos;
        uniform float uTemp;
        uniform float uIntensity;
        uniform vec3 uBaseColor;
        uniform float uTime;
        varying vec3 vWorldPos;
        varying vec3 vWorldNormal;
        varying vec3 vLocalPos;

        float hash(vec2 p) {
          p = fract(p * vec2(123.34, 456.21));
          p += dot(p, p + 45.32);
          return fract(p.x * p.y);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec2 u = f * f * (3.0 - 2.0 * f);
          float a = hash(i + vec2(0.0, 0.0));
          float b = hash(i + vec2(1.0, 0.0));
          float c = hash(i + vec2(0.0, 1.0));
          float d = hash(i + vec2(1.0, 1.0));
          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }

        float fbm(vec2 p) {
          float sum = 0.0;
          float amp = 0.5;
          for (int i = 0; i < 5; i++) {
            sum += amp * noise(p);
            p = p * 2.03 + vec2(1.71, -0.83);
            amp *= 0.5;
          }
          return sum;
        }

        void main() {
          vec3 N = normalize(vWorldNormal);
          vec3 V = normalize(uCamPos - vWorldPos);
          float mu = max(dot(N, V), 0.0);
          float limb = 0.72 + 0.28 * pow(mu, 0.35);
          float fres = pow(1.0 - mu, 2.9);

          vec2 uv;
          uv.x = atan(vLocalPos.z, vLocalPos.x) / 6.28318530718 + 0.5;
          uv.y = asin(clamp(vLocalPos.y, -1.0, 1.0)) / 3.14159265359 + 0.5;
          vec2 drift = vec2(uTime * 0.014, -uTime * 0.009);
          float gran1 = fbm(uv * 180.0 + drift * 8.0);
          float gran2 = fbm(uv * 380.0 - drift * 13.0);
          float gran3 = fbm((uv.yx + vec2(0.23, 0.71)) * 620.0 + drift * 21.0);
          float micro = mix(gran1, gran2, 0.45);
          micro = mix(micro, gran3, 0.24);
          float hotspots = smoothstep(0.72, 0.98, micro);

          vec3 cool = vec3(0.42, 0.66, 1.18);
          vec3 hot = vec3(1.05, 1.28, 1.95);
          vec3 thermal = mix(cool, hot, uTemp);

          vec3 col = thermal * (1.05 + micro * 0.42 + hotspots * 0.25);
          col *= limb;
          col += vec3(0.23, 0.56, 1.05) * fres * 0.42;
          col = mix(col, col * 1.08 + uBaseColor * 0.25, 0.45);

          float outIntensity = mix(1.2, 2.15, clamp(uIntensity, 0.0, 2.2));
          gl_FragColor = vec4(col * outIntensity, 1.0);
        }
      `;

      const starGeometry = new THREE.SphereGeometry(1.0, 128, 96);
      const starUniformTemplate = {
        uCamPos: { value: camera.position.clone() },
        uTemp: { value: 0.65 },
        uIntensity: { value: 1.0 },
        uBaseColor: { value: new THREE.Color(0.58, 0.75, 1.0) },
        uDeformDir: { value: new THREE.Vector3(1, 0, 0) },
        uDeform: { value: 0.0 },
        uTime: { value: 0.0 },
      };

      function cloneUniforms(uniforms) {
        return {
          uCamPos: { value: uniforms.uCamPos.value.clone() },
          uTemp: { value: uniforms.uTemp.value },
          uIntensity: { value: uniforms.uIntensity.value },
          uBaseColor: { value: uniforms.uBaseColor.value.clone() },
          uDeformDir: { value: uniforms.uDeformDir.value.clone() },
          uDeform: { value: uniforms.uDeform.value },
          uTime: { value: uniforms.uTime.value },
        };
      }

      const starMat1 = new THREE.ShaderMaterial({
        uniforms: cloneUniforms(starUniformTemplate),
        vertexShader: starVertexShader,
        fragmentShader: starFragmentShader,
        transparent: false,
      });
      starMat1.uniforms.uBaseColor.value.setRGB(0.58, 0.77, 1.0);

      const starMat2 = new THREE.ShaderMaterial({
        uniforms: cloneUniforms(starUniformTemplate),
        vertexShader: starVertexShader,
        fragmentShader: starFragmentShader,
        transparent: false,
      });
      starMat2.uniforms.uBaseColor.value.setRGB(0.64, 0.80, 1.0);

      const star1 = new THREE.Mesh(starGeometry, starMat1);
      const star2 = new THREE.Mesh(starGeometry, starMat2);
      scene.add(star1);
      scene.add(star2);

      const remnant = new THREE.Mesh(
        new THREE.SphereGeometry(0.34, 48, 48),
        new THREE.MeshBasicMaterial({ color: new THREE.Color(1.0, 0.92, 1.0), transparent: true, opacity: 0.95 })
      );
      remnant.visible = false;
      scene.add(remnant);

      const pointSpriteVertexShader = /* glsl */ `
        precision highp float;
        attribute float aSize;
        attribute float aPhase;
        varying vec3 vColor;
        varying float vPhase;
        uniform float uBaseSize;
        uniform float uScale;
        uniform float uTime;

        void main() {
          vColor = color;
          vPhase = aPhase;
          vec4 mv = modelViewMatrix * vec4(position, 1.0);
          float dist = max(1.0, -mv.z);
          float twinkle = 0.86 + 0.14 * sin(uTime * 0.9 + aPhase);
          gl_PointSize = uBaseSize * aSize * uScale * twinkle / dist;
          gl_Position = projectionMatrix * mv;
        }
      `;

      const pointSpriteFragmentShader = /* glsl */ `
        precision highp float;
        varying vec3 vColor;
        varying float vPhase;
        uniform float uOpacity;
        uniform float uSoftness;
        uniform float uCoreBoost;
        uniform float uTime;

        void main() {
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float r2 = dot(uv, uv);
          if (r2 > 1.0) {
            discard;
          }

          float halo = exp(-r2 * (2.4 + uSoftness * 0.9));
          float core = exp(-r2 * (8.5 + uSoftness * 1.8)) * uCoreBoost;
          float scint = 0.90 + 0.10 * sin(uTime * 2.2 + vPhase * 1.7);
          float alpha = (halo + core) * uOpacity * scint;
          gl_FragColor = vec4(vColor * (halo * 0.7 + core * 1.35), alpha);
        }
      `;

      const burstCount = 2600;
      const burstPositions = new Float32Array(burstCount * 3);
      const burstVel = new Float32Array(burstCount * 3);
      const burstColor = new Float32Array(burstCount * 3);
      const burstSize = new Float32Array(burstCount);
      const burstPhase = new Float32Array(burstCount);
      const burstGeom = new THREE.BufferGeometry();
      burstGeom.setAttribute("position", new THREE.BufferAttribute(burstPositions, 3));
      burstGeom.setAttribute("color", new THREE.BufferAttribute(burstColor, 3));
      burstGeom.setAttribute("aSize", new THREE.BufferAttribute(burstSize, 1));
      burstGeom.setAttribute("aPhase", new THREE.BufferAttribute(burstPhase, 1));
      const burstMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0.0 },
          uOpacity: { value: 0.0 },
          uBaseSize: { value: 42.0 },
          uScale: { value: Math.min(window.devicePixelRatio, 2.0) },
          uSoftness: { value: 1.15 },
          uCoreBoost: { value: 1.25 },
        },
        vertexShader: pointSpriteVertexShader,
        fragmentShader: pointSpriteFragmentShader,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        vertexColors: true,
      });
      const burstPoints = new THREE.Points(burstGeom, burstMat);
      burstPoints.visible = false;
      burstPoints.frustumCulled = false;
      scene.add(burstPoints);

      function initBurstDirections() {
        for (let i = 0; i < burstCount; i++) {
          const i3 = i * 3;
          const theta = 2.0 * Math.PI * Math.random();
          const mixComp = Math.random();
          let dir = new THREE.Vector3();
          let speed = 0.0;
          let r = 1.0;
          let g = 1.0;
          let b = 1.0;

          if (mixComp < 0.52) {
            // Equatorial tidal ejecta: slower and warmer.
            const z = (Math.random() * 2.0 - 1.0) * 0.24;
            const rr = Math.sqrt(Math.max(0.0, 1.0 - z * z));
            dir.set(rr * Math.cos(theta), rr * Math.sin(theta), z).normalize();
            speed = 2.3 + Math.random() * 6.6 + Math.pow(Math.random(), 2.2) * 6.0;
            r = 0.98;
            g = 0.74 + Math.random() * 0.14;
            b = 0.95;
          } else if (mixComp < 0.84) {
            // Polar component: faster, lanthanide-poor, bluer.
            const polarSign = Math.random() < 0.5 ? -1.0 : 1.0;
            const z = polarSign * (0.70 + Math.random() * 0.30);
            const rr = Math.sqrt(Math.max(0.0, 1.0 - z * z));
            dir.set(rr * Math.cos(theta), rr * Math.sin(theta), z).normalize();
            speed = 5.2 + Math.random() * 10.5 + Math.pow(Math.random(), 2.7) * 10.0;
            r = 0.72;
            g = 0.90 + Math.random() * 0.10;
            b = 1.00;
          } else {
            // Quasi-isotropic hot flash debris.
            const u = Math.random();
            const v = Math.random();
            const phi = Math.acos(2.0 * v - 1.0);
            dir.set(Math.sin(phi) * Math.cos(theta), Math.sin(phi) * Math.sin(theta), Math.cos(phi));
            speed = 4.0 + Math.random() * 12.0 + Math.pow(Math.random(), 3.0) * 14.0;
            r = 0.90 + Math.random() * 0.10;
            g = 0.78 + Math.random() * 0.16;
            b = 1.00;
          }

          burstVel[i3 + 0] = dir.x * speed;
          burstVel[i3 + 1] = dir.y * speed;
          burstVel[i3 + 2] = dir.z * speed;

          burstColor[i3 + 0] = r;
          burstColor[i3 + 1] = g;
          burstColor[i3 + 2] = b;
          burstSize[i] = 0.55 + Math.pow(Math.random(), 2.0) * 1.55;
          burstPhase[i] = Math.random() * Math.PI * 2.0;

          burstPositions[i3 + 0] = 0;
          burstPositions[i3 + 1] = 0;
          burstPositions[i3 + 2] = 0;
        }
        burstGeom.attributes.position.needsUpdate = true;
      }
      initBurstDirections();

      const starfieldCount = 2200;
      const starfieldPositions = new Float32Array(starfieldCount * 3);
      const starfieldColor = new Float32Array(starfieldCount * 3);
      const starfieldSize = new Float32Array(starfieldCount);
      const starfieldPhase = new Float32Array(starfieldCount);
      for (let i = 0; i < starfieldCount; i++) {
        const i3 = i * 3;
        const r = 80 + Math.random() * 240;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starfieldPositions[i3 + 0] = r * Math.sin(phi) * Math.cos(theta);
        starfieldPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        starfieldPositions[i3 + 2] = r * Math.cos(phi);

        const tint = Math.random();
        starfieldColor[i3 + 0] = 0.70 + 0.28 * tint;
        starfieldColor[i3 + 1] = 0.76 + 0.22 * (1.0 - tint * 0.65);
        starfieldColor[i3 + 2] = 0.95 + 0.05 * Math.random();
        starfieldSize[i] = 0.55 + Math.pow(Math.random(), 1.8) * 1.95;
        starfieldPhase[i] = Math.random() * Math.PI * 2.0;
      }
      const starfieldGeom = new THREE.BufferGeometry();
      starfieldGeom.setAttribute("position", new THREE.BufferAttribute(starfieldPositions, 3));
      starfieldGeom.setAttribute("color", new THREE.BufferAttribute(starfieldColor, 3));
      starfieldGeom.setAttribute("aSize", new THREE.BufferAttribute(starfieldSize, 1));
      starfieldGeom.setAttribute("aPhase", new THREE.BufferAttribute(starfieldPhase, 1));
      const starfieldMat = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0.0 },
          uOpacity: { value: 0.82 },
          uBaseSize: { value: 34.0 },
          uScale: { value: Math.min(window.devicePixelRatio, 2.0) },
          uSoftness: { value: 1.65 },
          uCoreBoost: { value: 1.05 },
        },
        vertexShader: pointSpriteVertexShader,
        fragmentShader: pointSpriteFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true,
      });
      const starfield = new THREE.Points(starfieldGeom, starfieldMat);
      scene.add(starfield);

      const ambient = new THREE.AmbientLight(0xffffff, 0.25);
      scene.add(ambient);

      const ACT1_DURATION = 18.0;
      const ACT2_DURATION = 1.0;
      const ACT3_DURATION = 44.0;
      const TOTAL_DURATION = ACT1_DURATION + ACT2_DURATION + ACT3_DURATION;

      const params = {
        timeScale: 1.0,
        m1: 1.50,
        m2: 1.38,
        ejectaMass: 0.074,
        polarVel: 0.34,
        eqVel: 0.118,
        opacityContrast: 1.56,
        rtStrength: 1.64,
        jetAngle: 10.8,
        jetIntensity: 2.35,
        remnantLum: 1.58,
        bloomStrength: 1.62,
        chromaticAberration: 0.12,
        sharpen: 0.72,
        autoQuality: false,
        qualityTier: 0,
      };

      const state = {
        playing: true,
        simTime: 0,
        act: 1,
        actTime: 0,
        act2Progress: 0,
        act3Progress: 0,
        remnantFade: 0.0,
        physicalDays: 0.03,
        collisionElapsed: 0,
        fpsSmooth: 60,
        adaptTimer: 0,
        currentQualityTier: 0,
        cameraMotion: 0,
        forceHistoryReset: true,
        prevAct: 1,
      };

      const tmpDir12 = new THREE.Vector3();
      const tmpDir21 = new THREE.Vector3();
      const tmpProj1 = new THREE.Vector3();
      const tmpProj2 = new THREE.Vector3();
      const origin = new THREE.Vector3(0, 0, 0);
      const tmpAxisPlus = new THREE.Vector3();
      const tmpAxisMinus = new THREE.Vector3();
      const tmpOriginProj = new THREE.Vector3();
      const tmpToCam = new THREE.Vector3();
      const prevCamPos = camera.position.clone();
      const prevCamQuat = camera.quaternion.clone();

      const qualityProfiles = [
        { name: "Ultra", steps: 140, octaves: 5, pixelRatio: Math.min(window.devicePixelRatio, 2.0), volumeScale: volumeScaleByTier[0] },
        { name: "High", steps: 118, octaves: 4, pixelRatio: Math.min(window.devicePixelRatio, 1.8), volumeScale: volumeScaleByTier[1] },
        { name: "Medium", steps: 92, octaves: 3, pixelRatio: Math.min(window.devicePixelRatio, 1.4), volumeScale: volumeScaleByTier[2] },
        { name: "Low", steps: 70, octaves: 2, pixelRatio: Math.min(window.devicePixelRatio, 1.1), volumeScale: volumeScaleByTier[3] },
      ];

      function smoothstep(edge0, edge1, x) {
        const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
      }

      function clamp(x, a, b) {
        return Math.min(Math.max(x, a), b);
      }

      function mapExp01(x, minVal, maxVal) {
        const logMin = Math.log(minVal);
        const logMax = Math.log(maxVal);
        return Math.exp(logMin + (logMax - logMin) * x);
      }

      function setQualityTier(tier, force = false) {
        const next = clamp(Math.round(tier), 0, qualityProfiles.length - 1);
        if (!force && next === state.currentQualityTier) {
          return;
        }

        state.currentQualityTier = next;
        params.qualityTier = next;
        const profile = qualityProfiles[next];
        renderer.setPixelRatio(profile.pixelRatio);
        currentVolumeScale = profile.volumeScale;
        onResize();

        volumeMaterial.uniforms.uSteps.value = Number(profile.steps);
        volumeMaterial.uniforms.uNoiseOctaves.value = Number(profile.octaves);
        state.forceHistoryReset = true;

        const qEl = document.getElementById("qualityTier");
        qEl.value = String(next);
        document.getElementById("qualityTierValue").textContent = `${next} (${profile.name})`;
      }

      function bindSlider(id, key, formatter) {
        const el = document.getElementById(id);
        const valueEl = document.getElementById(`${id}Value`);
        el.value = String(params[key]);
        valueEl.textContent = formatter(params[key]);
        el.addEventListener("input", () => {
          params[key] = parseFloat(el.value);
          valueEl.textContent = formatter(params[key]);
        });
      }

      bindSlider("m1", "m1", (v) => v.toFixed(2));
      bindSlider("m2", "m2", (v) => v.toFixed(2));
      bindSlider("ejectaMass", "ejectaMass", (v) => v.toFixed(3));
      bindSlider("polarVel", "polarVel", (v) => v.toFixed(3));
      bindSlider("eqVel", "eqVel", (v) => v.toFixed(3));
      bindSlider("opacityContrast", "opacityContrast", (v) => v.toFixed(2));
      bindSlider("rtStrength", "rtStrength", (v) => v.toFixed(2));
      bindSlider("jetAngle", "jetAngle", (v) => `${v.toFixed(1)} deg`);
      bindSlider("jetIntensity", "jetIntensity", (v) => v.toFixed(2));
      bindSlider("remnantLum", "remnantLum", (v) => v.toFixed(2));
      bindSlider("bloomStrength", "bloomStrength", (v) => v.toFixed(2));
      bindSlider("chromaticAberration", "chromaticAberration", (v) => v.toFixed(2));
      bindSlider("sharpen", "sharpen", (v) => v.toFixed(2));

      const timelineEl = document.getElementById("timeline");
      const timelineValueEl = document.getElementById("timelineValue");
      const timeScaleEl = document.getElementById("timeScale");
      const timeScaleValueEl = document.getElementById("timeScaleValue");
      const uiPanel = document.getElementById("ui");
      const settingsToggleBtn = document.getElementById("settingsToggle");
      const hudAct = document.getElementById("hudAct");
      const hudSim = document.getElementById("hudSim");
      const hudPhys = document.getElementById("hudPhys");
      const hudFPS = document.getElementById("hudFPS");
      const hudQuality = document.getElementById("hudQuality");
      const hudSteps = document.getElementById("hudSteps");

      let panelCollapsed = false;

      function setPanelCollapsed(collapsed) {
        panelCollapsed = collapsed;
        uiPanel.classList.toggle("collapsed", collapsed);
        settingsToggleBtn.textContent = collapsed ? "Settings âš™" : "Hide Settings âš™";
        settingsToggleBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
      }

      settingsToggleBtn.addEventListener("click", () => {
        setPanelCollapsed(!panelCollapsed);
      });
      setPanelCollapsed(false);

      timeScaleEl.value = String(params.timeScale);
      timeScaleValueEl.textContent = `${params.timeScale.toFixed(2)}x`;
      timeScaleEl.addEventListener("input", () => {
        params.timeScale = parseFloat(timeScaleEl.value);
        timeScaleValueEl.textContent = `${params.timeScale.toFixed(2)}x`;
      });

      timelineEl.addEventListener("input", () => {
        state.simTime = (parseFloat(timelineEl.value) / 1000) * TOTAL_DURATION;
        state.forceHistoryReset = true;
      });

      const playPauseBtn = document.getElementById("playPause");
      const restartBtn = document.getElementById("restart");

      playPauseBtn.addEventListener("click", () => {
        state.playing = !state.playing;
        playPauseBtn.textContent = state.playing ? "Pause" : "Play";
      });

      restartBtn.addEventListener("click", () => {
        state.simTime = 0;
        state.playing = true;
        state.forceHistoryReset = true;
        playPauseBtn.textContent = "Pause";
      });

      const autoQualityEl = document.getElementById("autoQuality");
      const autoQualityValueEl = document.getElementById("autoQualityValue");
      const manualQualityEl = document.getElementById("qualityTier");

      function refreshQualityControls() {
        manualQualityEl.disabled = params.autoQuality;
      }

      autoQualityEl.checked = params.autoQuality;
      autoQualityValueEl.textContent = params.autoQuality ? "On" : "Off";
      autoQualityEl.addEventListener("change", () => {
        params.autoQuality = autoQualityEl.checked;
        autoQualityValueEl.textContent = params.autoQuality ? "On" : "Off";
        refreshQualityControls();
        if (!params.autoQuality) {
          setQualityTier(parseInt(manualQualityEl.value, 10), true);
        }
      });

      manualQualityEl.value = String(params.qualityTier);
      manualQualityEl.addEventListener("input", () => {
        const tier = parseInt(manualQualityEl.value, 10);
        if (!params.autoQuality) {
          setQualityTier(tier, true);
        }
      });
      refreshQualityControls();

      function setDefaultCameraView() {
        camera.position.set(31.0, 6.2, 0.0);
        controls.target.set(0, 0, 0);
        controls.update();
        state.forceHistoryReset = true;
      }

      function updateBurst(collisionTime, totalMassScale) {
        const fade = Math.exp(-collisionTime * 0.6);
        const opacity = clamp(1.45 * fade, 0, 1.0);
        burstMat.uniforms.uOpacity.value = opacity;
        burstPoints.visible = opacity > 0.01;

        for (let i = 0; i < burstCount; i++) {
          const i3 = i * 3;
          const vx = burstVel[i3 + 0] * totalMassScale;
          const vy = burstVel[i3 + 1] * totalMassScale;
          const vz = burstVel[i3 + 2] * totalMassScale;

          const drag = 1.0 / (1.0 + collisionTime * 0.15);
          burstPositions[i3 + 0] = vx * collisionTime * drag;
          burstPositions[i3 + 1] = vy * collisionTime * drag;
          burstPositions[i3 + 2] = vz * collisionTime * drag;
        }
        burstGeom.attributes.position.needsUpdate = true;
      }

      function updateInspiral(elapsed, actTime) {
        const p = clamp(actTime / ACT1_DURATION, 0, 1);
        const m1 = params.m1;
        const m2 = params.m2;
        const mTotal = m1 + m2;
        const mScale = clamp(mTotal / 2.8, 0.72, 1.7);

        const chirpBoost = Math.pow(Math.max(0.04, 1.0 - 0.965 * p), -0.375);
        const phase = 2.0 * Math.PI * (2.0 * p + 5.6 * p * p + 18.0 * Math.pow(p, 4.0)) * mScale;

        const sep = clamp(7.8 - 6.0 * Math.pow(p, 0.76), 2.08, 8.0);
        const r1 = sep * (m2 / mTotal);
        const r2 = sep * (m1 / mTotal);

        const c = Math.cos(phase);
        const s = Math.sin(phase);
        star1.position.set(c * r1, s * r1, 0.07 * Math.sin(phase * 0.55));
        star2.position.set(-c * r2, -s * r2, -0.07 * Math.sin(phase * 0.55));
        star1.scale.setScalar(1);
        star2.scale.setScalar(1);

        const tidal = clamp(Math.pow(smoothstep(0.50, 1.0, p), 1.05) * 0.92, 0.0, 0.98);
        tmpDir12.subVectors(star2.position, star1.position).normalize();
        tmpDir21.copy(tmpDir12).multiplyScalar(-1);

        starMat1.uniforms.uDeform.value = tidal;
        starMat2.uniforms.uDeform.value = tidal;
        starMat1.uniforms.uDeformDir.value.copy(tmpDir12);
        starMat2.uniforms.uDeformDir.value.copy(tmpDir21);

        const temp = clamp(0.35 + 0.58 * smoothstep(0.18, 1.0, p), 0.0, 1.0);
        const intensity = 0.92 + 0.55 * smoothstep(0.2, 1.0, p) + 0.05 * chirpBoost;
        starMat1.uniforms.uTemp.value = temp;
        starMat2.uniforms.uTemp.value = temp * 0.96;
        starMat1.uniforms.uIntensity.value = intensity;
        starMat2.uniforms.uIntensity.value = intensity * 0.98;
        starMat1.uniforms.uTime.value = elapsed;
        starMat2.uniforms.uTime.value = elapsed + 0.35;
        starMat1.uniforms.uCamPos.value.copy(camera.position);
        starMat2.uniforms.uCamPos.value.copy(camera.position);

        star1.visible = true;
        star2.visible = true;
        remnant.visible = false;
        state.remnantFade = 0.0;

        burstMat.uniforms.uOpacity.value = 0.0;
        burstPoints.visible = false;
      }

      function updateCollision(elapsed, actTime, massScale) {
        const p = clamp(actTime / ACT2_DURATION, 0, 1);

        star1.visible = p < 0.65;
        star2.visible = p < 0.65;

        const collapse = 1.0 - smoothstep(0.0, 1.0, p);
        star1.scale.setScalar(0.6 + 0.4 * collapse);
        star2.scale.setScalar(0.6 + 0.4 * collapse);

        star1.position.lerp(origin, 0.14 + p * 0.2);
        star2.position.lerp(origin, 0.14 + p * 0.2);

        remnant.visible = true;
        remnant.position.set(0, 0, 0);
        const pulse = 1.0 + 0.25 * Math.sin(elapsed * 14.0);
        const remnantFade = 1.0 - 0.35 * p;
        remnant.scale.setScalar((0.85 + 0.55 * (1.0 - p)) * pulse);
        remnant.material.opacity = 0.88 * remnantFade;
        state.remnantFade = remnantFade;

        updateBurst(actTime, massScale);
      }

      function updateExpansion(elapsed, actTime, massScale) {
        const p = clamp(actTime / ACT3_DURATION, 0, 1);

        star1.visible = false;
        star2.visible = false;

        remnant.visible = false;
        remnant.material.opacity = 0.0;
        state.remnantFade = 0.0;

        updateBurst(ACT2_DURATION + actTime, massScale);

        state.act3Progress = p;
        state.physicalDays = mapExp01(Math.pow(p, 1.15), 0.03, 21.0);
      }

      function updateTimeline(delta) {
        if (state.playing) {
          state.simTime += delta * params.timeScale;
          while (state.simTime >= TOTAL_DURATION) {
            state.simTime -= TOTAL_DURATION;
          }
          if (state.simTime < 0) {
            state.simTime = 0;
          }
        }

        timelineEl.value = String(Math.round((state.simTime / TOTAL_DURATION) * 1000));
        timelineValueEl.textContent = `${state.simTime.toFixed(2)} s`;

        if (state.simTime < ACT1_DURATION) {
          state.act = 1;
          state.actTime = state.simTime;
          state.act2Progress = 0;
          state.act3Progress = 0;
          state.physicalDays = 0.03;
        } else if (state.simTime < ACT1_DURATION + ACT2_DURATION) {
          state.act = 2;
          state.actTime = state.simTime - ACT1_DURATION;
          state.act2Progress = clamp(state.actTime / ACT2_DURATION, 0, 1);
          state.act3Progress = 0;
          state.physicalDays = 0.03;
        } else {
          state.act = 3;
          state.actTime = state.simTime - ACT1_DURATION - ACT2_DURATION;
          state.act2Progress = 1.0;
        }

        if (state.act !== state.prevAct) {
          state.forceHistoryReset = true;
          state.prevAct = state.act;
        }
      }

      function updatePerformance(delta) {
        const fps = 1.0 / Math.max(delta, 1e-4);
        state.fpsSmooth = THREE.MathUtils.lerp(state.fpsSmooth, fps, 0.06);

        if (!params.autoQuality) {
          return;
        }

        state.adaptTimer += delta;
        if (state.adaptTimer < 1.2) {
          return;
        }

        state.adaptTimer = 0;

        if (state.fpsSmooth < 50 && state.currentQualityTier < qualityProfiles.length - 1) {
          setQualityTier(state.currentQualityTier + 1, true);
        } else if (state.fpsSmooth > 57 && state.currentQualityTier > 0) {
          setQualityTier(state.currentQualityTier - 1, true);
        }
      }

      function updateAct(elapsed) {
        const totalMass = params.m1 + params.m2;
        const massScale = clamp(Math.pow(totalMass / 2.8, 0.70), 0.70, 1.65);
        const actLabel = state.act === 1 ? "Inspiral" : state.act === 2 ? "Collision" : "Kilonova Expansion";
        const qualityProfile = qualityProfiles[state.currentQualityTier];

        if (state.act === 1) {
          updateInspiral(elapsed, state.actTime);
        } else if (state.act === 2) {
          updateCollision(elapsed, state.actTime, massScale);
        } else {
          updateExpansion(elapsed, state.actTime, massScale);
        }

        let tSinceMerger = -1.0;
        if (state.act === 2) {
          tSinceMerger = state.actTime;
        } else if (state.act === 3) {
          tSinceMerger = ACT2_DURATION + state.actTime;
        }

        tmpToCam.copy(camera.position).sub(origin).normalize();
        const cosViewAxis = Math.abs(tmpToCam.z);
        const jetOpen = THREE.MathUtils.degToRad(Math.max(3.0, params.jetAngle));
        const directAngleWeight = smoothstep(Math.cos(jetOpen + THREE.MathUtils.degToRad(8.0)), Math.cos(jetOpen), cosViewAxis);

        let grbDirect = 0.0;
        let grbCocoon = 0.0;
        let grbShockR = 0.0;
        if (tSinceMerger >= 0.0) {
          const directCore = Math.exp(-Math.pow((tSinceMerger - 0.22) / 0.18, 2.0));
          const directTail = Math.exp(-tSinceMerger / 0.55) * (1.0 - smoothstep(1.1, 2.0, tSinceMerger));
          grbDirect = (directCore + 0.36 * directTail) * directAngleWeight * massScale * 1.35;

          const cocoonRise = smoothstep(0.05, 0.55, tSinceMerger);
          const cocoonMain = 1.0 - smoothstep(2.8, 4.8, tSinceMerger);
          const cocoonTail = 0.35 * Math.exp(-Math.max(0.0, tSinceMerger - 1.0) / 2.2);
          const cocoonTemporal = cocoonRise * cocoonMain + cocoonTail;
          const cocoonAngleWeight = 0.66 + 0.34 * (1.0 - directAngleWeight);
          grbCocoon = cocoonTemporal * cocoonAngleWeight * massScale * 0.92;
          grbShockR = clamp(0.06 + 0.10 * tSinceMerger + 0.025 * tSinceMerger * tSinceMerger, 0.06, 0.72);
        }
        grbDirect = clamp(grbDirect, 0.0, 2.0);
        grbCocoon = clamp(grbCocoon, 0.0, 1.4);

        const flash = state.act === 2 ? Math.exp(-state.act2Progress * 8.8) * (2.0 * massScale) : 0.0;
        renderer.toneMappingExposure = 1.0 + flash * 0.32 + grbDirect * 0.34 + grbCocoon * 0.14;

        const volUniforms = volumeMaterial.uniforms;
        const compUniforms = compositeMaterial.uniforms;
        const tempUniforms = temporalMaterial.uniforms;

        volUniforms.uCamPos.value.copy(camera.position);
        volUniforms.uInvProj.value.copy(camera.projectionMatrixInverse);
        volUniforms.uInvView.value.copy(camera.matrixWorld);
        volUniforms.uTime.value = elapsed;
        volUniforms.uAct.value = state.act;
        volUniforms.uAct2Progress.value = state.act2Progress;
        volUniforms.uAct3Progress.value = state.act3Progress;
        volUniforms.uDays.value = state.physicalDays;
        volUniforms.uCollisionFlash.value = flash;
        volUniforms.uEnergyScale.value = massScale;
        volUniforms.uEjectaMass.value = params.ejectaMass;
        volUniforms.uPolarVel.value = params.polarVel;
        volUniforms.uEqVel.value = params.eqVel;
        volUniforms.uOpacityContrast.value = params.opacityContrast;
        volUniforms.uRTStrength.value = params.rtStrength;
        volUniforms.uJetAngle.value = params.jetAngle;
        volUniforms.uJetIntensity.value = params.jetIntensity;
        volUniforms.uRemnantLum.value = state.act === 2 ? params.remnantLum * state.remnantFade : 0.0;

        const act2BloomScale = state.act === 2 ? (0.80 + 0.20 * state.act2Progress) : 1.0;
        compUniforms.uBloomStrength.value = params.bloomStrength * act2BloomScale;
        compUniforms.uAct.value = state.act;
        compUniforms.uAct2Progress.value = state.act2Progress;
        compUniforms.uChromAb.value = params.chromaticAberration;
        compUniforms.uSharpen.value = params.sharpen;
        compUniforms.uGRBDirect.value = grbDirect;
        compUniforms.uGRBCocoon.value = grbCocoon;
        compUniforms.uGRBShockR.value = grbShockR;

        tmpOriginProj.copy(origin).project(camera);
        if (tmpOriginProj.z > -1.0 && tmpOriginProj.z < 1.0) {
          compUniforms.uGRBCenter.value.set(tmpOriginProj.x * 0.5 + 0.5, tmpOriginProj.y * 0.5 + 0.5);
        } else {
          compUniforms.uGRBCenter.value.set(0.5, 0.5);
        }

        tmpAxisPlus.set(0, 0, 1).project(camera);
        tmpAxisMinus.set(0, 0, -1).project(camera);
        const ax = tmpAxisPlus.x - tmpAxisMinus.x;
        const ay = tmpAxisPlus.y - tmpAxisMinus.y;
        const alen = Math.hypot(ax, ay);
        if (alen > 1e-5) {
          compUniforms.uGRBAxisDir.value.set(ax / alen, ay / alen);
        } else {
          compUniforms.uGRBAxisDir.value.set(1.0, 0.0);
        }

        let stepScale = 1.0;
        let noiseScale = 1.0;
        if (state.act === 2) {
          stepScale = 1.08 - 0.10 * state.act2Progress;
          noiseScale = 0.94 + 0.12 * state.act2Progress;
        } else if (state.act === 3) {
          const earlyImpulse = Math.exp(-state.act3Progress * 5.8);
          const lateRelax = smoothstep(0.18, 1.0, state.act3Progress);
          stepScale = clamp(1.06 + 0.34 * earlyImpulse - 0.24 * lateRelax, 0.68, 1.36);
          noiseScale = clamp(0.98 + 0.20 * earlyImpulse - 0.08 * lateRelax, 0.74, 1.28);
        }
        volUniforms.uStepScale.value = stepScale;
        volUniforms.uNoiseScale.value = noiseScale;

        let starVis1 = 0.0;
        let starVis2 = 0.0;
        if (star1.visible) {
          tmpProj1.copy(star1.position).project(camera);
          if (tmpProj1.z > -1.0 && tmpProj1.z < 1.0) {
            compUniforms.uStarScreen1.value.set(tmpProj1.x * 0.5 + 0.5, tmpProj1.y * 0.5 + 0.5);
            starVis1 = 1.0;
          } else {
            compUniforms.uStarScreen1.value.set(-10, -10);
          }
        } else {
          compUniforms.uStarScreen1.value.set(-10, -10);
        }
        if (star2.visible) {
          tmpProj2.copy(star2.position).project(camera);
          if (tmpProj2.z > -1.0 && tmpProj2.z < 1.0) {
            compUniforms.uStarScreen2.value.set(tmpProj2.x * 0.5 + 0.5, tmpProj2.y * 0.5 + 0.5);
            starVis2 = 1.0;
          } else {
            compUniforms.uStarScreen2.value.set(-10, -10);
          }
        } else {
          compUniforms.uStarScreen2.value.set(-10, -10);
        }
        compUniforms.uStarVis1.value = starVis1;
        compUniforms.uStarVis2.value = starVis2;

        let historyBlend = 0.0;
        let historyReset = 1.0;
        if (state.act >= 2) {
          const motionSuppression = clamp(1.0 - state.cameraMotion * 18.0, 0.0, 1.0);
          const phaseBlend =
            state.act === 2 ? 0.52 + 0.18 * state.act2Progress : 0.62 + 0.24 * smoothstep(0.0, 0.55, state.act3Progress);
          historyBlend = phaseBlend * motionSuppression;
          historyReset = 0.0;
        }
        if (state.forceHistoryReset) {
          historyBlend = 0.0;
          historyReset = 1.0;
          state.forceHistoryReset = false;
        }
        tempUniforms.uHistoryBlend.value = historyBlend;
        tempUniforms.uHistoryReset.value = historyReset;
        tempUniforms.tCurrent.value = volumeCurrentTarget.texture;
        tempUniforms.tHistory.value = volumeHistoryRead.texture;
        compUniforms.tVolume.value = volumeHistoryRead.texture;

        hudAct.textContent = `Phase: ${actLabel}`;
        hudSim.textContent = `t_sim: ${state.simTime.toFixed(1)} / ${TOTAL_DURATION.toFixed(1)} s`;
        if (state.act === 3) {
          hudPhys.textContent = `Epoch: ${state.physicalDays.toFixed(2)} d post-merger`;
        } else if (state.act === 2) {
          hudPhys.textContent = "Epoch: contact to 10^3 ms post-merger";
        } else {
          hudPhys.textContent = "Epoch: terminal pre-merger inspiral";
        }
        hudFPS.textContent = `FPS: ${state.fpsSmooth.toFixed(1)}`;
        hudQuality.textContent = `Quality: ${qualityProfile.name}`;
        const effectiveSteps = Math.round(volUniforms.uSteps.value * volUniforms.uStepScale.value);
        hudSteps.textContent = `Steps: ${effectiveSteps}`;
      }

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        baseTarget.setSize(w, h);

        const volSize = getVolumeDimensions(w, h);
        volumeCurrentTarget.setSize(volSize.w, volSize.h);
        volumeHistoryTargetA.setSize(volSize.w, volSize.h);
        volumeHistoryTargetB.setSize(volSize.w, volSize.h);

        volumeMaterial.uniforms.uResolution.value.set(volSize.w, volSize.h);
        compositeMaterial.uniforms.uResolution.value.set(w, h);
        compositeMaterial.uniforms.uVolumeResolution.value.set(volSize.w, volSize.h);
        const pointScale = Math.min(window.devicePixelRatio, 2.0);
        burstMat.uniforms.uScale.value = pointScale;
        starfieldMat.uniforms.uScale.value = pointScale;
        state.forceHistoryReset = true;
      }

      window.addEventListener("resize", onResize);

      setQualityTier(0, true);
      setDefaultCameraView();

      const clock = new THREE.Clock();
      let prevTime = performance.now() * 0.001;

      function animate() {
        requestAnimationFrame(animate);

        const now = performance.now() * 0.001;
        const delta = Math.min(0.05, now - prevTime);
        prevTime = now;

        updateTimeline(delta);
        updatePerformance(delta);

        if (!params.autoQuality && state.currentQualityTier !== params.qualityTier) {
          setQualityTier(params.qualityTier, true);
        }

        controls.update();
        const camPosDelta = camera.position.distanceTo(prevCamPos);
        const camQuatDot = clamp(Math.abs(camera.quaternion.dot(prevCamQuat)), 0.0, 1.0);
        const camAngDelta = 2.0 * Math.acos(camQuatDot);
        state.cameraMotion = camPosDelta + camAngDelta * 3.5;
        if (camPosDelta > 0.0022 || camAngDelta > 0.0022) {
          state.forceHistoryReset = true;
        }
        prevCamPos.copy(camera.position);
        prevCamQuat.copy(camera.quaternion);

        const elapsed = clock.getElapsedTime();
        burstMat.uniforms.uTime.value = elapsed;
        starfieldMat.uniforms.uTime.value = elapsed;
        updateAct(elapsed);

        renderer.setRenderTarget(baseTarget);
        renderer.clear();
        renderer.render(scene, camera);

        renderer.setRenderTarget(volumeCurrentTarget);
        renderer.clear();
        renderer.render(volumeScene, postCamera);

        temporalMaterial.uniforms.tCurrent.value = volumeCurrentTarget.texture;
        temporalMaterial.uniforms.tHistory.value = volumeHistoryRead.texture;
        renderer.setRenderTarget(volumeHistoryWrite);
        renderer.clear();
        renderer.render(temporalScene, postCamera);
        swapVolumeHistoryTargets();
        compositeMaterial.uniforms.tVolume.value = volumeHistoryRead.texture;

        renderer.setRenderTarget(null);
        renderer.clear();
        renderer.render(compositeScene, postCamera);
      }

      animate();
    </script>
  </body>
</html>
